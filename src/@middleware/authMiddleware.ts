import { MiddlewareFn, UserRole } from "../@types";
import { ErrorHandler, logger, JWT } from "../@utils";
import SettingsRepository from "../@routes/settings/repository";
import AuthRepository from "../@routes/auth/repository";
import { STATUSCODE } from "../@constants";
import bcrypt from "bcrypt";

export class AuthMiddleware {
  constructor(
    private settingsRepository: SettingsRepository,
    private authRepository: AuthRepository,
    private jwtUtils: JWT
  ) {}

  /**
   * Verifies HTTP Basic Authentication credentials.
   *
   * Extracts and validates credentials from the `Authorization` header
   * using the `Basic` authentication scheme. This middleware is intended
   * to add an additional security layer to publicly accessible endpoints
   * (e.g., registration and login) by preventing unauthorized API access.
   * All Errors generated by `BasicAuthenticationVerifier` middleware are set  to be generic for security reasons, while the true error are only logged in the server.
   *
   * Requests with invalid or missing credentials are rejected.
   */
  BasicAuthenticationVerifier(): MiddlewareFn {
    //returns an async function with next middleware callback function
    return async (req, res, next) => {
      logger.info({
        BASIC_AUTH_REQUEST: {
          message: "SUCCESS",
        },
      });

      //Extract request headers
      const basicHeaders = req.headers["authorization"];

      //If the request headers are empty the request would become unauthorized (401).
      if (!basicHeaders) {
        //logs the error
        logger.info({
          BASIC_AUTH_ERROR: {
            message: "Missing Authorization Headers",
          },
        });
        //Throws a new Generic Error with 401 status
        throw new ErrorHandler(STATUSCODE.UNAUTHORIZED, "Unauthorized");
      }

      //Extract header type
      const basicType = basicHeaders.split(" ")[0];

      //If the type are not `Basic` a generic error will be thrown with 401 status.
      if (basicType !== "Basic") {
        // Error information is logged server-side to avoid leaking sensitive details.
        logger.info({
          BASIC_AUTH_ERROR: {
            message: "Invalid Authentication Type",
          },
        });
        throw new ErrorHandler(STATUSCODE.UNAUTHORIZED, "Unauthorized");
      }

      // Extract the Base64-encoded credentials from the Authorization header
      const basicCredentials = basicHeaders.split(" ")[1];

      // Decode the credentials into a "username:password" string
      const credentials = Buffer.from(basicCredentials, "base64").toString(
        "utf-8"
      );

      // Parse the username and password from the decoded credentials
      const [username, password] = credentials.split(":");

      //Check if the username from the parsed credentials exists in the settings collections.
      const result = await this.settingsRepository.getByUsername(username);

      /**
       * If no matching record is found, the result will be null or undefined.
       * In this case, a generic authentication error is thrown, while detailed
       * information is logged server-side to avoid leaking sensitive details.
       */
      if (!result) {
        logger.info({
          BASIC_AUTH_ERROR: {
            message: "Invalid Credentials",
          },
        });
        throw new ErrorHandler(STATUSCODE.UNAUTHORIZED, "Unauthorized");
      }

      // Compare the provided password with the hashed password stored in the database
      const isPasswordMatch = await bcrypt.compare(
        password, // The plaintext password extracted from the Authorization header
        result.settings_password // The hashed password retrieved from the user's settings in the database
      );

      // If the password does not match, log the failure and throw a generic authentication error
      if (!isPasswordMatch) {
        logger.info({
          BASIC_AUTH_ERROR: {
            message: "Invalid Credentials", // Generic message to avoid revealing whether the username or password was wrong
          },
        });
        throw new ErrorHandler(STATUSCODE.UNAUTHORIZED, "Unauthorized");
      }

      // Log a successful authentication attempt
      logger.info({
        BASIC_AUTH_RESPONSE: {
          message: "SUCCESS",
        },
      });

      // Call the next middleware or route handler since authentication passed
      next();
    };
  }

  // For Verifying access token attached from headers in the request object.
  AccessTokenVerifier(): MiddlewareFn {
    return async (req, res, next) => {
      logger.info({
        ACCESS_TOKEN_VERIFIER_REQUEST: {
          message: "Success",
        },
      });

      const access_token = req.headers["authorization"];

      if (!access_token) {
        logger.info({
          ACCESS_TOKEN_VERIFIER_ERROR: {
            message: "Missing authorization headers.",
          },
        });

        throw new ErrorHandler(STATUSCODE.UNAUTHORIZED, "Unauthorized.");
      }

      const credentials = await this.authRepository.getOneByAccessToken(
        access_token
      );

      if (!credentials) {
        logger.info({
          ACCESS_TOKEN_VERIFIER_ERROR: {
            message: "Credentials not found",
          },
        });

        throw new ErrorHandler(STATUSCODE.UNAUTHORIZED, "Unauthorized.");
      }

      //verify access token.
      this.jwtUtils.verifyAccessToken(access_token);

      logger.info({
        ACCESS_TOKEN_VERIFIER_RESPONSE: {
          message: "Success",
        },
      });

      next();
    };
  }

  RefreshTokenVerifier(): MiddlewareFn {
    return async (req, res, next) => {
      logger.info({
        REFRESH_TOKEN_VERIFIER_REQUEST: {
          message: "SUCCESS",
        },
      });

      const refresh_token = req.headers["authorization"];

      if (!refresh_token) {
        logger.info({
          REFRESH_TOKEN_VERIFIER_ERROR: {
            message: "Missing authorization headers.",
          },
        });

        throw new ErrorHandler(STATUSCODE.UNAUTHORIZED, "Unauthorized.");
      }

      const credentials = await this.authRepository.getOneByRefreshToken(
        refresh_token
      );

      if (!credentials) {
        logger.info({
          REFRESH_TOKEN_VERIFIER_ERROR: {
            message: "Credentials not found.",
          },
        });

        throw new ErrorHandler(STATUSCODE.UNAUTHORIZED, "Unauthorized.");
      }

      //verifies if the refresh token is still valid or not.
      this.jwtUtils.verifyRefreshToken(refresh_token);

      logger.info({
        REFRESH_TOKEN_VERIFIER_RESPONSE: {
          message: "SUCCESS",
        },
      });

      next();
    };
  }

  UserRoleVerifier(...roles: UserRole[]): MiddlewareFn {
    return (req, res, next) => {
      logger.info({
        USER_ROLE_VERIFIER_REQUEST: {
          message: "SUCCESS",
        },
      });

      const access_token = req.headers["authorization"];

      const verifiedAccessToken = this.jwtUtils.verifyAccessToken(
        access_token as string
      );

      if (!roles || !roles?.includes(verifiedAccessToken.user.role)) {
        logger.info({
          USER_ROLE_VERIFIER_ERROR: {
            message: "Access Denied, User not allowed to access resource.",
          },
        });
        throw new ErrorHandler(STATUSCODE.FORBIDDEN, "Forbidden");
      }
      logger.info({
        USER_ROLE_VERIFIER_RESPONSE: {
          message: "SUCCESS",
        },
      });
      next();
    };
  }
}
